-- Red75 (c) 2008
-- Marauder scheme v 1.1
-- Part of AMK MOD

evid_see_stuff=6931
evid_near_stuff=evid_see_stuff+1
evid_see_body=evid_see_stuff+2
evid_position_corrected=evid_see_stuff+3

actid_reach_item=evid_see_stuff
actid_grab_item=evid_see_stuff+1
actid_grab_body=evid_see_stuff+2
actid_correct_position=evid_see_stuff+3

-- Вызывает closure раз в period, obj[var] хранит время следующего срабатывания
function timed(obj,var,period,closure)
	if obj[var] and obj[var]<time_global() then
		obj[var]=time_global()+period
		closure()
	elseif not obj[var] then
		obj[var]=time_global()+period
	end
end

function trigger_timed(obj,var)
	obj[var]=time_global()
end

local disabled_objects={}

local corpse_checked={} -- true - has loot, false - hasn't loot, nil - not checked

function checkCorpse(obj)
    local obj_id = obj:id()
	if corpse_checked[obj_id]~=nil then
		return corpse_checked[obj_id]
	end
	local cnt=0
	obj:iterate_inventory(function (dummy, item)
        if item:section()~="bolt" then
          cnt=cnt+1
        end
	end, nil)
	corpse_checked[obj_id]=cnt>0
	return corpse_checked[obj_id]
end

local valuable_clsid={
    [clsid.artefact]=true,
    [clsid.artefact_s]=true,
    [clsid.device_detector_simple]=true,
    [clsid.device_pda]=true,
    [clsid.device_torch_s]=true,
    [clsid.equ_exo]=true,
    [clsid.equ_military]=true,
    [clsid.equ_scientific]=true,
    [clsid.equ_stalker_s]=true,
    [clsid.obj_antirad]=true,
    [clsid.obj_attachable]=true,
    [clsid.obj_bandage]=true,
    [clsid.obj_bottle]=true,
    [clsid.obj_food]=true,
    [clsid.obj_medkit]=true,
    [clsid.wpn_ammo]=true,
    [clsid.wpn_ammo_m209]=true,
    [clsid.wpn_ammo_og7b]=true,
    [clsid.wpn_ammo_vog25]=true,
    [clsid.wpn_binocular_s]=true,
    [clsid.wpn_fn2000]=true,
    [clsid.wpn_fort]=true,
    [clsid.wpn_scope_s]=true,
    [clsid.wpn_silencer]=true,
    [clsid.wpn_wmagaz]=true,
    [clsid.wpn_wmaggl]=true
}

local obj_owner={}

function isValuable(obj)
    if obj then 
		local sec=obj:section()
        if sec then
            if sec=="amk_metka" or protected_items.actor_items_keep(sec) then
				return false, false
			end
			
			local cls = obj:clsid()
			if valuable_clsid[cls] or IAmAWeapon[cls] then	-- if item
				return true, false
			elseif (IAmAStalker[cls] or IAmAMonster[cls]) and obj:alive() == false then	-- if corpse
				return checkCorpse(obj), true
			end
        end
    end
	return false, false
end

function objValue(obj)
	local sec=obj:section()
	local multiplier=1
    if string.find(sec,"^ammo_") then
        multiplier=30
    elseif sec=="vodka" then
        multiplier=20
	end
    return obj:cost()*multiplier
end

function claimGObject(npc,st,obj)
	if st.grabitemid then
		obj_owner[st.grabitemid]=nil
	end
	st.grabitemid=obj:id()
	obj_owner[obj:id()]=npc:id()
end

function freeGObject(st)
	if st.grabitemid then
		obj_owner[st.grabitemid]=nil
		st.grabitemid=nil
	end
end

function clearGObject(st)
	st.grabitemid=nil
end

function getGObject(st)
	if st.grabitemid then
		local ret=level_object(st.grabitemid)
		if ret==nil then
			st.grabitemid=nil
		end 
		return ret
	end
	return nil
end

function mypGObject(npc,st)
	return st.grabitemid~=nil and obj_owner[st.grabitemid]~=nil and obj_owner[st.grabitemid]==npc:id()
end

class "ev_see_stuff" (property_evaluator)

function ev_see_stuff:__init(st,name) super(nil, name)
	self.st=st
end

local bad_dangers={
	 [danger_object.hit]=true,
	 [danger_object.attacked]=true,
	 [danger_object.bullet_ricochet]=true,
	 [danger_object.grenade]=true,
	 [danger_object.entity_death]=true,
	 [danger_object.enemy_sound]=true
}

local inertion_time=30000

function bad_danger(npc)
	local danger=npc:best_danger()
	if danger then
		return bad_dangers[danger:type()] and time_global()-danger:time()<inertion_time
	end
	return false
end

function ev_see_stuff:evaluate()
	local npc=self.object

	local res=getGObject(self.st)~=nil
	local npc_id = npc:id()
	local stor = db.storage[npc_id]
	local actsch = stor.active_scheme

--	if actsch then
--		xr_logic.try_switch_to_another_section(npc, stor[actsch], db.actor)
--	end

	if (not npc:alive()) or xr_wounded.is_wounded(npc)
		or (npc:relation(db.actor) == game_object.enemy)
		or npc:best_enemy() or bad_danger(npc)
		or (actsch and stor[actsch].no_loot)
	then
		if res then freeGObject(self.st) end
		return false
	end 

	if res and self.st.block_search then return true end

	local act_sec = stor.active_section or ""
	
	local dist_limit=1000
	if string.find(act_sec,"^camper") then
		dist_limit=5
	end

	local busy = string.find(act_sec,"^walker")
		or string.find(act_sec,"^combat")
		or string.find(act_sec,"^danger")

	timed(self.st,"tm1",5000+math.random()*10000,
		function ()
			local min_dist=100000
			local function check_item(o, e)
				local obj=o:object()
				local obj_id = obj:id()

				if obj_owner[obj_id] then
					local o_owner = level.object_by_id(obj_owner[obj_id])
					if o_owner==nil or o_owner:alive()==false then
						obj_owner[obj_id]=nil
					end
				end

				if (not self.st.disabled_objects[obj_id])
					and ( obj:parent()==nil
					or not IAmAStalker[obj:parent():clsid()] )
					and ( obj_owner[obj_id]==nil
					or obj_owner[obj_id]==npc_id )
					and npc:accessible(obj:level_vertex_id())
					and ( db.actor:alive()==false
					or db.actor:position():distance_to_sqr(obj:position())>6 )
				then
					local valuable,corpse=isValuable(obj)
					if valuable then
						local value=3000
						if not corpse then value=objValue(obj) end

                        local max_dist=5+math.sqrt(value)

						if busy then max_dist=max_dist/5 end

						local dist=level.vertex_position(obj:level_vertex_id()):distance_to(npc:position())
						local corrected_dist=dist
						if dist>5 then corrected_dist=5+(dist-5)/math.sqrt(value) end

						if dist<max_dist
							and corrected_dist<min_dist
							and dist<dist_limit
						then
							min_dist=corrected_dist
							claimGObject(npc,self.st,obj)
							res=true
						end
					end
				end
			end -- function check_item

			for o in npc:memory_visible_objects() do
				check_item(o)
			end
		-- Отключено, чтобы неписи не отвлекались на то, чего не видели.
		-- Да и тормозов меньше, т.к. среди этих объектов, как правило,
		-- все видимые (те, что перебирались выше),
		-- плюс те, которые не видели, но слышали.
		--	for o in npc:memory_sound_objects() do
		--		check_item(o)
		--	end
            --if res then
            --end
		end
	)
	return res
end

class "ev_near_stuff" (property_evaluator)

function ev_near_stuff:__init(st,name) super(nil, name)
	self.st=st
end

function ev_near_stuff:evaluate()
	local npc=self.object
	local gi=getGObject(self.st)
	if gi then
		if self.st.dest_lvid then
			return npc:level_vertex_id()==self.st.dest_lvid
		end
		return level.vertex_position(gi:level_vertex_id()):distance_to_sqr(npc:position())<1
	end
	return false
end

class "ev_see_body" (property_evaluator)

function ev_see_body:__init(st) super(nil, "ev_see_body")
	self.st=st
end

function ev_see_body:evaluate()
	local npc=self.object
	local gi=getGObject(self.st)
    if gi then
        return IAmAStalker[gi:clsid()] or IAmAMonster[gi:clsid()]
	end

	return false
end

class "ev_position_corrected" (property_evaluator)

function ev_position_corrected:__init(st) super(nil, "ev_position_corrected")
	self.st=st
end

function ev_position_corrected:evaluate()
	return self.st.position_corrected==true
end

class "act_grab_item" (action_base)

function act_grab_item:__init (action_name, st) super (nil, action_name)
	self.st = st
end

function act_grab_item:initialize()
	action_base.initialize(self)
	
	local npc=self.object
	npc:set_item(object.idle,nil)
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)
	npc:movement_enabled(true)
	
	local gi=getGObject(self.st)
	npc:set_sight(look.danger,nil,0)
	self.st.block_search=true
    
	if gi then
        if(IAmAStalker[gi:clsid()] or IAmAMonster[gi:clsid()]) then
			self.tt=time_global()+3000
		else
			self.tt=time_global()+1000
			utils.send_to_nearest_accessible_vertex(npc,gi:level_vertex_id())
		end
	end
	
	self.force=vector():set(0,0,0)
end

function act_grab_item:execute()
	action_base.execute(self)
	
	local npc=self.object
	local gi=getGObject(self.st)
	if not gi then
		return
	end
	
	if self.tt<time_global() then
		if gi and gi:parent()==nil then
			gi:transfer_item(gi,npc)
			npc:enable_memory_object(gi,false)
		end
		
		-- Тут нельзя освобождать объект. transfer_item выполняется асинхронно. Поэтому делаем clearGObject
		clearGObject(self.st)
	end
end

function act_grab_item:finalize()
	local npc=self.object
	self.st.block_search=nil
	npc:set_sight(look.danger,nil,0)
	trigger_timed(self.st,"tm1")
	self.st.dest_lvid=nil -- Очищаем скорректированную точку назначения
	
	action_base.finalize(self)
end

class "act_grab_body" (action_base)

function act_grab_body:__init (st) super (nil, "act_grab_body")
	self.st = st
end

function act_grab_body:initialize()
	action_base.initialize(self)
	
	local npc=self.object
	local gi=getGObject(self.st)
	self.st.block_search=true
	if gi then
		self.tt=time_global()+6000
		state_mgr.set_state(npc,"search",nil,nil,{look_object=gi})
		-- Осматриваем тело, говорим что-то вроде "тааак, посмотрим..."
		if IAmAStalker[gi:clsid()] and self.st.need_loot_snd==nil then
			xr_sound.set_sound_play(npc, "loot_begin")
			self.st.need_loot_snd = true
		end
	else
		self.st.dest_lvid=nil
	end
end

function act_grab_body:execute()
	action_base.execute(self)

	local npc=self.object
	local gi=getGObject(self.st)
	if not gi then
		self.st.dest_lvid=nil
		return
	end

	if self.tt<time_global() then
		if gi and gi:parent()==nil then
			-- Посчитаем примерную стоимость хабара
			local isstalker = IAmAStalker[gi:clsid()]~=nil
			local num = 0
			gi:iterate_inventory(function (d,item)
					if not protected_items.is_grab_body_item_keep(item:section()) then
						if isstalker then
							num = num + item:cost() * item:condition()
						end
						gi:transfer_item(item,npc)
					end
				end,
            nil)

			if isstalker then
				-- По стоимости награбленного определяем, что будем говорить
				self.st.loot_snd = "loot_"..(num > 5000 and "good" or "bad")

				num=gi:money() 
				if num and num >0 then 
					local deadmoney = num
					local gi_rank = ranks.get_obj_rank_name(gi)
					if gi_rank ~= nil then
						if gi_rank == "novice" and deadmoney >=70 then
							deadmoney=math.random(25,70)    
						elseif gi_rank == "experienced" and deadmoney >=150 then
							deadmoney=math.random(50,150)  
						elseif gi_rank == "veteran" and deadmoney >=220 then
							deadmoney=math.random(100,220) 
						elseif gi_rank == "master" and deadmoney >=300 then
							deadmoney=math.random(200,300)  
						end
					end
					
					npc:give_money(deadmoney) 
					gi:give_money(-num) 
				end
			end
 
			corpse_checked[gi:id()]=false
		end

		-- Тут нельзя освобождать объект. transfer_item выполняется асинхронно. Поэтому делаем clearGObject
		clearGObject(self.st)
	end
end

function act_grab_body:finalize()
	local npc=self.object
	self.st.block_search=nil
	trigger_timed(self.st,"tm1")
	-- говорим, как хабар: хорошо или не очень
	if self.st.need_loot_snd and self.st.loot_snd then
		xr_sound.set_sound_play(npc, self.st.loot_snd)
		self.st.need_loot_snd = nil
		self.st.loot_snd = nil
	end
	self.st.dest_lvid=nil -- Очищаем скорректированную точку назначения
	
	action_base.finalize(self)
end

function correct_position(gi,npc)
    if IAmAStalker[gi:clsid()] then
		-- Вычисляем вектор разницы между координатами кости и level vertex. Пытаемся найти level vertex наиболее близкий к кости
		local diff=gi:bone_position("bip01_head"):sub(level.vertex_position(gi:level_vertex_id()))
		local len=diff:magnitude()
		local diffp=vector():set(diff.z,0,-diff.x):mul(0.5)
		
		-- Сдвигаем целевую точку вбок, чтобы непись не залазил ногами в труп
		diff:add(diffp)
		return npc:vertex_in_direction(gi:level_vertex_id(),diff,len)
	else
		return gi:level_vertex_id()
	end
end

class "act_reach_item" (action_base)

function act_reach_item:__init (action_name, st) super (nil, action_name)
	self.st = st
end

function act_reach_item:initialize()
	action_base.initialize(self)

	local npc=self.object
	local gi=getGObject(self.st)
	self.st.dest_lvid=nil
	self.tgt_lvid=0

	if gi then
		if npc:accessible(gi:level_vertex_id()) then
			npc:set_detail_path_type(move.curve)
			npc:set_path_type(game_object.level_path)
			
			if npc:best_danger() and time_global()-npc:best_danger():time()<inertion_time then
				npc:set_mental_state(anim.danger)
				npc:set_body_state(move.crouch)
				npc:set_movement_type(move.walk)
			else 
				npc:set_body_state(move.standing)
				npc:set_mental_state(anim.free)
				npc:set_movement_type(move.walk)
			end
			
			npc:movement_enabled(true)
			npc:set_sight(look.danger,nil,0)
			self.st.dest_lvid=correct_position(gi,npc)
			self.tgt_lvid=gi:level_vertex_id()
			npc:set_dest_level_vertex_id(self.st.dest_lvid)
		else
			freeGObject(self.st)
		end
	end

	self.ct=time_global()
	self.clvid=npc:level_vertex_id()
	self.st.position_corrected=false
end

function act_reach_item:execute()
	action_base.execute(self)
	
	local npc=self.object
	local gi=getGObject(self.st)
	if gi and gi:parent()~=nil then
		-- ГГ забрал вкусность. Можно добавить наезд на ГГ.
		self.st.dest_lvid=nil
		freeGObject(self.st)

	elseif gi then
		if self.clvid==npc:level_vertex_id() then
			if time_global()-self.ct>10000 then
				self.st.disabled_objects[gi:id()]=true
				self.st.dest_lvid=nil
				freeGObject(self.st)
			end
		else
			self.clvid=npc:level_vertex_id()
			self.ct=time_global()
		end
		
		if self.tgt_lvid~=gi:level_vertex_id() then
			self.tgt_lvid=gi:level_vertex_id()
			self.st.dest_lvid=correct_position(gi,npc)
			npc:set_dest_level_vertex_id(self.st.dest_lvid)
		end
	end
end

function add_to_binder(object, char_ini, scheme, section, st)
	local npc=object
	st.disabled_objects={}
	local manager = object:motivation_action_manager()

	local comm = npc:character_community()
	local npc_name = npc:name()
	local zombi = ( comm=="zombied"
					or comm=="trader"
					or npc:section() == "stalker_sakharov"	-- отсекаем бессмертных квестовиков
					or comm=="arena_enemy"
					or npc_name=="mil_stalker0012"
					or npc_name=="yantar_ecolog_general" -- сумашедший на милитари и Сахаров
					or npc_name=="mil_freedom_member0021" -- Скрягу в зомби!
					or npc_name=="stalk_semetskiy"	-- Юра Семецкий в Лиманске
					or protected_items.is_no_offline_alife_npc(npc:section()) ) -- квестовики snp

	local prop_idlecombat=xr_evaluators_id.state_mgr + 3
	local prop_contact=xr_evaluators_id.stohe_meet_base + 1
 
	if npc:story_id()~=4294967296 or zombi then
		manager:add_evaluator(evid_see_stuff, property_evaluator_const(false))
		manager:add_evaluator(evid_see_body, property_evaluator_const(false))
		manager:add_evaluator(evid_near_stuff, property_evaluator_const(false))
		manager:add_evaluator(evid_position_corrected, property_evaluator_const(false))
	else
		manager:add_evaluator(evid_see_stuff, ev_see_stuff(st,"ev_see_stuff"))
		manager:add_evaluator(evid_see_body, ev_see_body(st))
		manager:add_evaluator(evid_position_corrected, ev_position_corrected(st))
		manager:add_evaluator(evid_near_stuff, ev_near_stuff(st,"ev_near_stuff"))
		
		local action = act_grab_item("act_grab_item", st)
		action:add_precondition(world_property(stalker_ids.property_alive,true))
		action:add_precondition(world_property(stalker_ids.property_enemy,false))
		action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base,false))
		action:add_precondition(world_property(blowout_scheme.evid_anomaly,false))
		action:add_precondition(world_property(blowout_scheme.evid_blowout,false))
		action:add_precondition(world_property(evid_see_stuff,true))
		action:add_precondition(world_property(evid_near_stuff,true))
		action:add_precondition(world_property(evid_see_body,false))
		action:add_precondition(world_property(prop_idlecombat,true)) -- отключим стэйт менеджер
		action:add_effect(world_property(evid_near_stuff, false))
		action:add_effect(world_property(evid_see_stuff, false))
		action:add_effect(world_property(evid_see_body,true)) -- для переключения на обыск трупа
		manager:add_action (actid_grab_item, action)

		action = act_grab_body(st)
		action:add_precondition(world_property(stalker_ids.property_alive,true))
		action:add_precondition(world_property(stalker_ids.property_enemy,false))
		action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base,false))
		action:add_precondition(world_property(blowout_scheme.evid_anomaly,false))
		action:add_precondition(world_property(blowout_scheme.evid_blowout,false))
		action:add_precondition(world_property(evid_see_stuff,true))
		action:add_precondition(world_property(evid_see_body,true))
		action:add_precondition(world_property(evid_near_stuff,true))
		action:add_effect(world_property(evid_near_stuff, false))
		action:add_effect(world_property(evid_see_stuff, false))
		action:add_effect(world_property(evid_see_body,false))
		manager:add_action (actid_grab_body, action)

		action = act_reach_item("act_reach_item", st)
		action:add_precondition(world_property(stalker_ids.property_alive,true))
		action:add_precondition(world_property(stalker_ids.property_enemy,false))
		action:add_precondition(world_property(prop_contact,false))
		action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base,false))
		action:add_precondition(world_property(blowout_scheme.evid_anomaly,false))
		action:add_precondition(world_property(blowout_scheme.evid_blowout,false))
		action:add_precondition(world_property(evid_see_stuff,true))
		action:add_precondition(world_property(evid_near_stuff,false))
		action:add_precondition(world_property(prop_idlecombat,true))
		action:add_effect (world_property(evid_near_stuff, true))
		manager:add_action (actid_reach_item, action)

		action = manager:action(xr_actions_id.alife)
		action:add_precondition(world_property(evid_see_stuff,false))
		action = manager:action(stalker_ids.action_danger_planner)
		action:add_precondition(world_property(evid_see_stuff,false))
	end
end

function set_scheme(npc, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.ini=ini
end 
