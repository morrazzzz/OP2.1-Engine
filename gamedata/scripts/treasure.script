-- Рандомные тайники
local rare_list = {
	novice_section = {
		"wpn_toz34",
		"wpn_ak74",
		"wpn_mp5_m1",
		"wpn_colt_m1",
		"wpn_mp5_m2",
		"wpn_walther_m1",
		"wpn_fort_m1",
		"scientific_outfit",
		"stalker_outfit_v3",
		"specops_outfit",
		"dolg_gaz_outfit_m1",
		"ammo_12x70_buck",
		"ammo_5.45x39_fmj",
		"ammo_5.56x45_ss190",
		"ammo_7.62x39_fmj",
		"ammo_9x39_pab9",
		"ammo_40sw_hp",
		"ammo_9x21_11",
		"ammo_9x19_pbp",
		"ammo_11.43x23_hydro",
		"ammo_zhekan_izomorf",
		"part_flesh_eye",		
		"part_boar_leg",		
		"part_dog_tail",		  			
		"part_zombie_hand",		
		"part_face_tushkano",		
		"part_tail_cat",				   
		"part_spleen_rat",
		"part_plague_hand",
		"af_medusa",
		"af_vyvert",
		"af_blood",
		"af_electra_sparkler",
		"af_rusty_thorn",
		"af_ameba_slime",
		"af_drops",      	
		"af_ameba_mica",
		"af_soul",
		"af_night_star",
		"af_electra_moonlight",
		"af_gravi",
		"af_cristall_flower",
		"af_mincer_meat",
		"af_electra_flash",
		"af_rusty_kristall",
		"af_ameba_slug",
		"af_fireball",
		"medkit",
		"outfit_soldier_m1",
		"neytral_novice_outfit_m1",
		"neytral_novice_outfit_new",
		"neytral_novice_outfit_cam_1",
		"neytral_novice_outfit_cam_2",
		"neytral_novice_outfit_cam_3",
		"bandit_outfit",
		"bandit_outfit_blue",
		"bandit_outfit_red",
		"mushroom",
		"wpn_knife",
		"sigaret",
		"mutant_tushkano_cocoon",
		"mutant_dog_cocoon",
		"mutant_psevdodog_cocoon",
		"mutant_flesh_cocoon",
		"mutant_cat_cocoon",
		"mutant_boar_cocoon",
	},
	experienced_section = {
		"ammo_7.62x54_7h1",
		"ammo_7.62x54_ap",
		"ammo_7.62x54_7h14",
		"ammo_12x70_buck",
		"ammo_5.45x39_ap",
		"ammo_5.56x45_ap",
		"ammo_9x39_pab9",
		"ammo_9x21_10",
		"ammo_40sw_ap",
		"ammo_og-7b",
		"ammo_5.45x39_izomorf",
		"ammo_7.62x39_ap",
		"ammo_7.62x51box",
		"part_zombie_hand",
		"part_snork_leg",				
		"part_poltergeist_glas",				
		"part_fracture_hand", 
		"part_boar_leg",
		"part_carlic_hand",
		"part_tarakan_strong",
		"part_vypolzen_hrebet",
		"part_fang_wolf",
		"part_nosales_tongue",
		"wpn_m16a2_sk1",
		"wpn_sg552_sk1",
		"wpn_wincheaster1300",
		"wpn_m4",
		"wpn_ppsh41_sk2",
		"wpn_abakan_m1",
		"wpn_fort_m1",
		"wpn_winchester_m1",
		"wpn_l85_m1",
		"wpn_l85_m2",
		"wpn_beretta_m1",
		"military_outfit",
		"svoboda_heavy_outfit",
		"dolg_scientific_outfit",
		"freedom_scientific_outfit",
		"merc_scientific_outfit",
		"monolit_scientific_outfit",
		"nebo_scientific_outfit",
		"outfit_dolg_m1",
		"outfit_killer_m1",
		"af_fuzz_kolobok",
		"af_rusty_sea-urchin",
		"af_ameba_mica",
		"af_soul",
		"af_night_star",
		"af_dummy_glassbeads",
		"af_dummy_pellicle",
		"af_dummy_battery",
		"af_dummy_dummy",
		"af_dummy_spring",
		"af_babka_1",
		"af_spirit_1",
		"medkit_army",
		"mutant_zombie_cocoon",
		"mutant_snork_cocoon",
		"mutant_poltergeist_cocoon",
		"amk_kanistra",
	},
	veteran_section = {
		"af_fuzz_kolobok",
		"af_spirit_1",        
		"af_spirit_2",       
		"af_cry_1",
		"af_babka_1",
		"af_pudd_1",
		"af_pudd_2",
		"af_dik_1",
		"af_kol_1",
		"af_armor_1",
		"af_armor_2",
		"af_dummy_dummy",
		"af_dummy_spring",
		"af_eye_voron",
		"ammo_og-7b",
		"grenade_flash",
		"ammo_vog-25p",
		"ammo_7.62x54_7h1",
		"ammo_7.62x54_ap",
		"ammo_7.62x54_7h14",
		"ammo_7.62x39_k",
		"ammo_12x70_buck",
		"ammo_44mag_hp",
		"ammo_7.92x33_fmj",
		"ammo_9x39_ap",
		"ammo_9x39_sp5",
		"ammo_9x39_izomorf",
		"ammo_minigun",
		"ammo_5.56x45_gd",
		"ammo_20x85",
		"ammo_7.62x51_fmj",
		"ammo_gauss",
		"nebo_exo_outfit",
		"part_krovosos_jaw",		
		"part_burer_hand",
		"part_zombie_hand",	
		"part_hand_kontroler",			
		"part_psevdogigant_hand",			
		"part_chimera_kogot",
		"part_spider_gland",
		"part_rotan_heart",
		"part_zanoza_leg",
		"part_winger_liver",
		"wpn_spas12",
		"wpn_m1891_30_scope",
		"wpn_groza",
		"medkit_scientic",
		"mutant_krovosos_cocoon",
		"mutant_burer_cocoon",
		"mutant_chimera_cocoon",
		"amk_ballon",
	},
	master_section = {
		"wpn_spas12",
		"wpn_groza",
		"wpn_val_m1",
		"wpn_protecta",	
		"wpn_mp5k_pdw57",
		"wpn_mp5k_pdw_tt",
		"wpn_g3_otdaca_ves",
		"part_krovosos_jaw",		
		"part_burer_hand",		
		"part_hand_kontroler",				
		"part_psevdogigant_hand",					
		"part_chimera_kogot",
		"part_deathclaw_antler",
		"part_raptor_kogot",
		"part_plague_hand",
		"part_bear_paw",
		"mozg",
		"ammo_7.62x54_7h1",
		"ammo_7.62x54_ap",
		"ammo_7.62x54_7h14",
		"ammo_12x70_buck",
		"ammo_og-7b",
		"grenade_rgd5",
		"ammo_7.62x54_izomorf",
		"ammo_44mag_ap",
		"ammo_7.62x54r",
		"ammo_7.62x51_ap",
		"ammo_7.92x33_ap",
		"ammo_357_hp_mag",
		"ammo_12.7x108r",
		"ammo_balon",
		"ammo_12.7x108",
		"ammo_12.7x55_fmj",
		"ammo_12.7x55_ap",
		"ammo_super_gauss",
		"svoboda_exoskeleton",
		"nebo_exo_outfit",
		"exo_bandit_outfit",
		"voen_exo_outfit",
		"exo_scientist_outfit",
		"exo_outfit",
		"dolg_black_exoskeleton",
		"killer_green_exoskeleton",
		"seva_scient_outfit",
		"af_simbion",        
		"af_spirit_2",         
		"af_cry_2",
		"af_babka_2",
		"af_pudd_2",
		"af_babka_3",
		"af_dik_2",
		"af_kol_2",
		"af_kol_3",
		"af_armor_2", 
		"af_armor_3",
		"suvorotka",
		"medkit_scientic",
		"mutant_gigant_cocoon",
		"mutant_controller_cocoon",
	}
}

local solid_list = {
	novice_section = {
		--Артефакты--
		"af_drops",
		"af_ameba_slime",
		"af_rusty_thorn",
		"af_electra_sparkler",
		"af_blood",
		"af_vyvert",
		"af_medusa",
		--Аммуниция--
		"grenade_rgd5",
		"ammo_12x70_buck",     
		"ammo_9x19_fmj",
		"ammo_9x19_pbp",
		"ammo_9x18_pmm",
		"ammo_9x18_fmj",
		--Оружие--
		"wpn_addon_silencer",
		"wpn_mp5",
		"wpn_bm16",
		"wpn_fort",
		"wpn_pb",
		"wpn_pm",
		--Прочее--
		"bread",
		"bandage",
		"kolbasa",
		"medkit",
		"vodka",
		"sigaret",
		"conserva"
	},
	experienced_section = {
		--Артефакты--
		"af_cristall_flower",
		"af_gravi",
		"af_mincer_meat",
		"af_electra_flash",
		"af_rusty_kristall",
		"af_ameba_slug",
		"af_fireball",
		--Аммуниция--
		"grenade_rgd5",
		"grenade_gd-05",
		"grenade_flash",
		"grenade_f1",     
		"ammo_9x19_pbp",
		"ammo_9x18_pmm",
		"ammo_5.45x39_fmj",
		"ammo_11.43x23_fmj",
		"ammo_5.56x45_ss190",
		--Пушки--
		"wpn_addon_scope",
		"wpn_mp5",
		"wpn_ak74u",
		"wpn_ak74u_m1",
		"wpn_walther",
		--Прочее--
		"part_dog_tail",
		"part_boar_leg",
		"kolbasa",
		"medkit",
		"antirad",
		"energy_drink",
		"conserva"
	},
	veteran_section = {
		--Артефакты--
		"af_night_star",
		"af_gold_fish",
		"af_soul",
		"af_electra_moonlight",
		"af_rusty_sea-urchin",
		"af_ameba_mica",
		"af_cristall",
		--Аммуниция--
		"grenade_f1",
		"ammo_vog-25",     
		"ammo_m209",
		"ammo_5.45x39_ap",
		"ammo_11.43x23_hydro",
		"ammo_9x39_pab9",
		"ammo_5.56x45_ss190",
		"ammo_12x76_zhekan",
		--Пушки--
		"wpn_addon_scope_susat",
		"wpn_addon_grenade_launcher",
		"wpn_beretta",
		"wpn_sig550",
		"wpn_toz34",
		"wpn_abakan_m2",
		"wpn_desert_eagle",
		--Прочее--
		"part_psevdodog_tail",
		"part_snork_leg",
		"medkit_army",
		"antirad"
	},
	master_section = {
		--Артефакты--
		"af_dummy_glassbeads",
		"af_dummy_pellicle",
		"af_dummy_battery",
		"af_dummy_dummy",
		"af_dummy_spring",
		"af_fuzz_kolobok",
		--Аммуниция--
		"ammo_m209",
		"ammo_vog-25p",     
		"ammo_9x39_ap",
		"ammo_12x76_dart",
		"ammo_7.62x54_7h14",
		"ammo_9x39_sp5",
		"ammo_5.56x45_ap",
		"ammo_7.62x54_7h1",
		--Пушки--
		"wpn_addon_grenade_launcher_m203",
		"wpn_colt1911",
		"wpn_spas12",
		"wpn_l85",
		"wpn_lr300",
		"wpn_groza",
		"wpn_groza_m1",
		--Прочее--
		"part_krovosos_jaw",
		"part_burer_hand",
		"medkit_army",
		"medkit_scientic"
	}
}

function parse_spawns(line)
	if line == nil then
		return {}
	end

	--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
	local t = se_respawn.parse_names(line)
	local n = table.getn(t)
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		table.insert(ret_table, spawn)
	end
	return ret_table
end

class "CTreasure"

function CTreasure:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.ini = ini_file("misc\\treasure.ltx")

	--' Итерируемся по всем настройкам фраз
	if not self.ini:section_exist("list") then
		abort("There is no section [list] in treasure.ltx")
	end
	
	local result, id, value = 0,"",""

	--' начальная установка
	self.treasure_info = {}
	self.total = self.ini:line_count("list")

	for i=0,self.total-1 do
		result, id, value	= self.ini:r_line("list",i,"","")
		
		self.treasure_info[id] = {}

		self.treasure_info[id].target		= utils.cfg_get_number(self.ini, id, "target", nil, true)
		self.treasure_info[id].named		= utils.cfg_get_bool(self.ini, id, "named", nil, false)
		self.treasure_info[id].name			= utils.cfg_get_string(self.ini, id, "name", nil, true, "")
		-- следующее не храним постоянно в памяти, а вычитываем из конфига при необходимости
		--self.treasure_info[id].description	= utils.cfg_get_string(self.ini, id, "description", nil, true, "")
		--self.treasure_info[id].items		= parse_spawns(utils.cfg_get_string(self.ini, id, "items", nil, true, ""))
		--self.treasure_info[id].condlist		= xr_logic.parse_condlist(utils.cfg_get_string(self.ini, id, "condlist", nil, true, ""))
		
		--' Отметим тайник как новый
		self.treasure_info[id].active = false
		self.treasure_info[id].done = false

		--print_table(self.treasure_info)
	end

	--' Вспомогательные таблицы для облегчения поиска
	self.treasure_by_target = {}
	for k,v in pairs(self.treasure_info) do
		self.treasure_by_target[v.target] = k	
	end
end

--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use(npc)
	printf("TREASURE USE")

	local se_npc = server_object(npc:id())
	if se_npc and se_npc.treasure_processed then return end
	se_npc.treasure_processed = true
	
	lootmoney.lootmoney(npc)

	local rarets 
	-- если выбран редкий тип тайников, то снизим вероятность его выпадения
	if amk.load_variable("option_treasure", 0) == 2 then 
	  rarets = 994
	else 
      rarets = 980
  end
	
	if math.random(1000) < rarets then 
	  return
	end
	
	--' Нужно рандомно выбрать один из тайников.
	local avail = {}
	local tr_sum = 0
	local treasure_prob

	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(npc, xr_logic.parse_condlist(utils.cfg_get_string(self.ini, k, "condlist", nil, true, "")))

			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end

			if tonumber(treasure_prob) >= 0 and v.active == false then
				if tonumber(treasure_prob) == 100 then
					self:give(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end

	if tr_sum == 0 or
		math.random(100) < 50
	then
		return
	end

	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			--' Выдать тайник
			self:give(v.k)
			break
		end
	end
end

function CTreasure:check()
	for k,v in pairs(self.treasure_info) do
		self:give(k)
	end
end

--' Напоминания об активных тайниках на текущей территории
function CTreasure:remind()
	local obj
	local have = false
	local txt = "%c[255,160,160,160]Тайники:\\n"
	
	for k,v in pairs(self.treasure_info) do
		if v.active then
			obj = story_object(v.target)
			if obj and object_level(obj) == ai:level_id() then
				txt = txt.."%c[170,200,200,200]"..game.translate_string(v.name).."\\n"
				have = true
			end
		end
	end
	
	if have then
		local task_texture, task_rect = get_texture_info("ui_iconsTotal_abstract5")
		db.actor:give_game_news(txt, task_texture, task_rect, 0, 30000)
	end
end

--' Выдача тайника
function CTreasure:give(k)
	local v = self.treasure_info[k]
	local obj = story_object(v.target)
	if obj ~= nil then
		if obj:clsid() ~= clsid.inventory_box then
			abort("Story object [%s] is not an inventory box", v.target)
		end
		
		news_manager.send_treasure(v.name, object_level_name(obj))

		--' Пометить на карте		
		local text = "%c[255,238,155,23]"..game.translate_string(v.name).."\\n".."%c[default]"..game.translate_string(utils.cfg_get_string(self.ini, k, "description", nil, true, ""))
		level.map_add_object_spot_ser(obj.id, "treasure", text)

		-- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if amk.load_variable("option_treasure", 0) ~= 0 and v.named == false then
		   v.items = self:give_item_list()
		else
			v.items = parse_spawns(utils.cfg_get_string(self.ini, k, "items", nil, true, ""))
		end  
		
		--' Сгенерить вещи
		for kk,vv in pairs(v.items) do
			for i=1,vv.prob do
				create(vv.section, obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id, obj.id)
			end
		end
		
		--' Пометим тайник как выданный
		self.treasure_info[k].active = true
		self.treasure_info[k].done = true

		-- Отправим тайник в оффлайн
		if obj.online then
			ai:set_switch_online(obj.id, false)
			ai:set_switch_offline(obj.id, true)
			amk.convert_npc[obj.id] = 1 -- ставим в очередь на вывод в онлайн
		end
	else
		printf("TREASURE %s, target doesnt exist", k)
	end
end

--' Выдача рандомного неименного тайника
function CTreasure:give_random()
	local result, id, value

	repeat
		result, id, value	= self.ini:r_line("list", math.random(self.total)-1, "", "")
	until self.treasure_info[id].named == false

	self:give(id)
end

--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
	printf("Treasure empty")
	local k = self.treasure_by_target[box_story_id]

	if k == nil or self.treasure_info[k] == nil then 
		return
	end

	self.treasure_info[k].active = false
	
	-- если тайник не именной, то переведен его в онлайн для следующей выдачи
	if self.treasure_info[k].named == false then
		self.treasure_info[k].done = false
	end
	
  level.map_remove_object_spot(box:id(), "treasure")
end

--' Сохранение
function CTreasure:save(p)
	--' Сохраняем размер таблицы
	local size = 0
	for k,v in pairs(self.treasure_info) do
		-- пишем состояние только активных тайников
		if v.active or v.done then
			size = size + 1
		end
	end
	p:w_u16(size)
	for k,v in pairs(self.treasure_info) do
		if v.active or v.done then
			p:w_u16(v.target)
			p:w_bool(v.active)
			p:w_bool(v.done)
		end
	end
end

--' Загрузка
function CTreasure:load(p)
	local t = p:r_u16()
	for i = 1,t do
		local k = self.treasure_by_target[p:r_u16()]
		self.treasure_info[k].active = p:r_bool()
		self.treasure_info[k].done = p:r_bool()
	end
end

function CTreasure:give_item_list()
	local ret = {}
	-- сколько наименований предметов будет в тайнике
	local i = math.random(1, 4)

	-- определим ранг непися
	local n_rank = math.random(1,12)*100
	local rank = ranks.get_rank_name_by_val(n_rank, true)
	
	-- определим, из какой секции брать предметы, и какие именно  
	local tbl
	if amk.load_variable("option_treasure", 0) == 1 then
		tbl = solid_list[rank.."_section"]
	else
		tbl = rare_list[rank.."_section"]
	end
	
	local cnt = 0
	local s, cls = "", ""
	for j = 1, i, 1 do
		s = table.random(tbl)

		-- установка кол-ва предметов в зависимости от секции
		cls = config:r_string(s, "class")
		if cls == "AMMO" then
			-- патроны
			cnt = math.random(1,3)
		elseif cls == "E_STLK" or cls == "W_SILENC" or cls == "W_GLAUNC" or string.find(cls, "WP_") then
			-- броники, оружие
			cnt = 1
		elseif string.find(s, "af") ~= nil or config:line_exist(s, "monster_part") then
			-- арты, запчасти
			cnt = math.random(1,2)
		else 
			cnt = math.random(1,5)
		end
  
		-- сохраняем инфу о текущем предмете
		table.insert(ret, {section = s, prob = cnt})
	end
	
	return ret
end

function take_item_from_box(box, box_story_id)
	printf("!!! take item from box %s", tostring(box:is_inv_box_empty()))
--	if box:is_inv_box_empty() == true then
		_G.Treasure:treasure_empty(box, box_story_id)
--	end
end

function CTreasure:dialog(npc)
	local avail = {}
	local tr_sum = 0
	local treasure_prob
	
	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(npc, xr_logic.parse_condlist(utils.cfg_get_string(self.ini, k, "condlist", nil, true, "")))
			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end
			if tonumber(treasure_prob) >= 0 and v.active == false then
				if tonumber(treasure_prob) == 100 then
					self:give(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end
	if tr_sum == 0 then
		return
	end
	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			self:give(v.k)
			break
		end
	end
end

function save(p)
	_G.Treasure:save(p)
end
function load(p)
	_G.Treasure:load(p)
end
function give()
	_G.Treasure:give_random()
end